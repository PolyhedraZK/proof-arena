---
problem_id: 1
title: A xor B
description: A xor B
draft: false
enable_comments: true
proposer: Polyhedra Network
proposer_icon: assets/icons/xxx.png (24x24)
---

## Problem Description

Your prover will verify an element-wise XOR operation on two boolean arrays.

### Input

- Two byte arrays, `A` and `B`
- Each element in `A` and `B` is a boolean value (0 or 1)
- Arrays `A` and `B` have the same length

### Operation

Perform an element-wise XOR (exclusive OR) between arrays `A` and `B`

### Output

- A new array `C` where each element is the result of `A[i] XOR B[i]`
- `C` will have the same length as `A` and `B`

### XOR Truth Table

|  A  |  B  | A XOR B |
| :-: | :-: | :-----: |
|  0  |  0  |    0    |
|  0  |  1  |    1    |
|  1  |  0  |    1    |
|  1  |  1  |    0    |

### Example

Input:

- `A = [1, 0, 1, 0]`
- `B = [0, 1, 1, 0]`

Output:

- `C = [1, 1, 0, 0]`

### Expected behaviour

Your verifier should accept the proof if the proof is generated by honest prover and `A XOR B == C`. Otherwise, your verifier should either crash or reject.

## Instructions

Your prover program must read bytes from stdin and print bytes to stdout. We will use a special judge program (SPJ) to interact with your prover by providing inputs and checking outputs. The SPJ communicates with the prover through the prover's stdin and stdout. Additionally, the SPJ will invoke your verifier to check your proof.

For detailed instructions on how to interact with the SPJ, refer to the [How to Interact with SPJ](https://github.com/PolyhedraZK/proof-arena/blob/main/docs/how_to_interact_with_SPJ.md) document.

### How to calculate the expected output:

- **Xor the Data:**

  - Between first N bytes and next N bytes, compute Xor.
  - The prover sends the hash results to the SPJ.
  - Prover Sample (Golang):

    ```golang
    func calculateExpectedOutput(in []byte, N int) []byte {
        A := in[:N]
        B := in[N:]
        C := make([]byte, N)
        for i := 0; i < N; i++ {
            C[i] = A[i] ^ B[i]
        }
        return C
    }
    ```

  ```golang
  expectedBytes := calculateExpectedOutput(in) // it calculates the hash of the input
  ipc.Write_byte_array(ProverToSPJPipe, expectedBytes)
  ```

  - Prover Sample (Rust):

    ```rust
    fn calculate_expected_output(input: &[u8], n: usize) -> Vec<u8> {
        let a = &input[..n];
        let b = &input[n..];
        let mut c = vec![0u8; n];
        for i in 0..n {
            c[i] = a[i] ^ b[i];
        }
        c
    }
    ```

  ```rust
  let expected_bytes = calculate_expected_output(&input, n); // it calculates the hash of the input
  ipc::write_byte_array(&mut prover_to_spj_pipe, &expected_bytes).unwrap();
  ```

## How to submit your solution?

- You need to submit a binary prover file that matches our requirements.
- You need to submit the source code of your verifier code that matches our requirements. The code will be reviewed and published on the website.

## Benchmark Details

We run the benchmark with N instances (represented as Instance Number in the table below) of the problem. The setup time, witness generation time, proof generation time are all averaged over N instances. We run verifier with single threaded execution, repeated multiple times and averaged over multiple runs.

- Setup time: the time before step 5 starts.
- Witness generation time: the time between end of step 5 and step 7.
- Proof generation time: the time between end of step 5 and step 8.
- Verification time: running time between end of step 8 and step 11.
- Peak memory: the peak memory usage of your program.
- Proof size: the byte length of the `YOUR PROOF BYTES` and `YOUR VERIFICATION KEY BYTES`. Your verifier will be audited, so please don't include any unnecessary data in the `YOUR PUBLIC INPUT BYTES`.
